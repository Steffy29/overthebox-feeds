#!/bin/sh
# shellcheck disable=SC1090,SC1091,SC1066,SC1087,SC2086,SC2016,SC2039
# vim: set noexpandtab tabstop=4 shiftwidth=4 softtabstop=4:
OCS_URL=192.168.100.10:8081

. /lib/overthebox
. /lib/functions/network.sh

_ocs_get() {
	path="$1"
	curl -s -m 10 --fail \
	-H "X-Auth-OVH: $OTB_TOKEN" \
	-H "X-Overthebox-Version: $(cat /etc/otb-version || echo 0.0-0)" \
	-L "$OCS_URL/device/$OTB_DEVICE_ID/ocs/$path"
}

_ocs_post(){
	path="$1"
	content="$2"
	curl --silent --show-error --max-time 5 \
		-X "POST" \
		-H "Content-Type: application/json" \
		-H "X-Auth-OVH: $OTB_TOKEN" \
		-H "X-Overthebox-Version: $(cat /etc/otb-version || echo 0.0-0)" \
		-L "$OCS_URL/device/$OTB_DEVICE_ID/ocs/$path"
		"$content"
}


_pull_config() {
	_ocs_get "config/get$1?version=$2"
}

_update_conf_status() {
	conf_path="$1"
	status="$2"

	_ocs_post "status/set$conf_path/$status"
}

_check_connect_acs() {
	reload_command="$1"
	if [ -z "$(uci changes)" ]; then
		logger "No changes, no need to check"
		return 0
	fi

	logger "Checking connectivity"
	local ret=0
	curl -s -m 10 --fail -L "$OCS_URL/ping" > /dev/null || ret=$?

	return $ret
}

# Deletes a conf if it's on the device but not in the conf sent by the server
_delete_old_confs() {
	local new_confs="$1"
	local local_confs="$2"

	# If there is no local_confs, there is nothing to delete
	if [ -z "$local_confs" ]; then
		return
	fi

	# If a conf is in local_confs and not in new_confs, delete it
	to_delete="$(printf "%s\n%s" "$new_confs" "$local_confs" |\
	awk '
	{
		a[$0] += 1
	}

	END{
		for(c in a){
			if(a[c] == 1){
				print c
			}
		}
	}')"

	if [ -z "$to_delete" ]; then
		return
	fi

	logger "Deleting conf for $to_delete"
	echo "$to_delete" | xargs -n 1 uci delete
}

# Checks if a conf has already been applied. This prevents from applying multiple
# times a conf that breaks the network
_check_cache() {
	local call_path="$1"

	touch "$ACS_CACHE_PATH"

	if grep "$call_path" "$ACS_CACHE_PATH"; then
		return 1
	fi

	echo "$call_path" >> "$ACS_CACHE_PATH"
}

# Gets all the confs at uci_path of type type generated by autoconfigure
_get_generated_conf() {
	local uci_path="$1"
	local type="$2"

	uci -q show "$uci_path" |\
	grep -E "$uci_path.*=$type" |\
	sed -E "s/\\=$type\$//g" | while read -r name; do
		uci show "$name" | grep "generatedby='autoconfigure'" |\
		sed "s/\.generatedby='autoconfigure'$//g"
	done
}

_set_conf_static() {
	local type="$1"
	local subtype="$2"
	local json_arr="$3"
	local reload_command="$4"
	local name_key="$5"
	local jq_filter="$6"
	local call_path="$7"

	local new_confs=

	# Check hash
	if ! _check_cache "$call_path"; then
		return 1
	fi

	confs="$(echo "$json_arr" | jq -r -c ".[]")"
	if [ -n "$confs" ]; then
		while read -r sconf; do
			name="$(echo "$sconf" | jq -r ".$name_key")"
			sconf="$(echo "$sconf" | jq -r "$jq_filter")"

			_set_conf_single_static	"$sconf" "$type.$name" "$subtype" "$call_path"

			new_confs="$(echo -e "$type.$name\n$new_confs")"
		done <<-EOT
			${confs}
		EOT
	fi

	_delete_old_confs "$new_confs" "$(_get_generated_conf "$type" "$subtype")"

	if [ -n "$(uci changes)" ]; then
		eval "$reload_command"
	fi
}

# Takes an input as { "key": "value" } and apply it as an uci configuration on uci_path as "set uci_path.key=value"
_set_conf_single_static() {
	local conf="$1"
	local uci_path="$2"
	local conf_type="$3"
	local call_path="$4"

	# Remove empty values and add "generatedby"
	conf="$(echo $conf | jq 'del(.[] | select(. == "null")) | . + {"generatedby": "autoconfigure"}')"

	logger "Updating $uci_path"

	# Map key to value
	uci set "$uci_path="
	uci set "$uci_path=$conf_type"
	echo "$conf" | jq -r --arg ucipath "$uci_path"  'to_entries | .[] | @text "set \($ucipath).\(.key)=\"\(.value)\""' | uci -q batch
}

# _set_conf_list sets conf as uci list
# conf: array of values eg: [ "value1", "value2" ]
# path: path of the list eg: dhcp.@dnsmasq[0].server
_set_conf_list() {
	local conf="$1"
	local key="$2"
	local uci_path="$3"
	local reload_command="$4"
	local call_path="$5"

	conf="$(echo "$conf" | jq -r "[.[].$key]")"

	if [ -z "$conf" ]; then
		return 1
	fi

	if ! _check_cache "$call_path" "$conf"; then
		return 1
	fi

	logger "Updating $uci_path"

	# Delete the list before adding values
	uci set "$uci_path="

	echo "$conf" | jq -r '.[]' | while read -r value; do
		uci add_list "$uci_path=$value"
	done

	if [ -n "$(uci changes)" ]; then
		eval "$reload_command"
	fi
}

# Finds the rule's index in uci that has the id "conf_id"
_find_rule_index() {
	local rule="$1"
	local conf_id="$2"

	found=false
	i=0
	id=
	while true; do
		uci show "$rule[$i]" > /dev/null 2>&1 || break

		id="$(uci get "$rule[$i].id" 2>/dev/null || true)"
		if [ "$id" = "$conf_id" ]; then
			found=true
			break
		fi
		i=$((i+1))
	done

	if [ "$found" = false ]; then
		echo "-1"
	else
		echo "$i"
	fi
}

# $1 is of format 192.168.2.5
# $2 is of format 192.168.2.0
_ip_belongs_to_network() {
	awk  -v ipaddr=$1 -v network=$2 '
	function ip2int(ip) {
        for (ret=0,n=split(ip,a,"\."),x=1;x<=n;x++) ret=or(lshift(ret,8),a[x])
        return ret
	}

	BEGIN{
			iip=ip2int(ipaddr)
			inet=ip2int(network)
			if (and(iip,inet) == inet){ exit 0 }
			else { exit 1 }
	}'

	return $?
}

# Gets the interface associated with this ip
_get_interface_ip() {
	ip=$1

	# Iterate over all interfaces
	uci show network | sed -n -E 's/network\.(\S*?)=interface/\1/p' |\
	while read -r iface; do

		# Get all ip of the interface
		ubus call network.interface dump  |\
		jq -r --arg iface "$iface"  '.interface[] | select(.interface == $iface) | .["ipv4-address"][]  | @text "\(.address)/\(.mask)"' 2>/dev/null | while read -r iface_subnet; do

			# Takes 192.168.2.5/24 as input and returns 192.168.2.0 as NETWORK
			eval "$(ipcalc.sh "$iface_subnet" | grep NETWORK)"
			if _ip_belongs_to_network "$ip" "$NETWORK"; then
				echo "$iface"
				return
			fi
		done
	done
}

# Sets conf in an array TODO: Improve this, seems a bit too hacky
_set_conf_array() {
	local conf="$1"

	# Is of shape: firewall.@rule
	uci_path_array="$2"
	jq_filter="$3"
	reload_command="$4"
	call_path="$5"

	# Filter null values
	jq_filter="[ .[] | $jq_filter ] | del(.[][] | select(. == \"null\"))"
	conf="$(echo "$conf" | jq -r "$jq_filter")"

	# Convert to firewall.rule
	uci_path="$(echo $uci_path_array | sed 's/\@//g')"

	# Convert to firewall rule
	uci_cmd="$(echo $uci_path | sed -n -r 's/(^[a-z]*)(\.)/\1 /p')"

	# Check hash
	if ! _check_cache "$call_path" "$conf"; then
		return 1
	fi

	logger "Updating $uci_path"

	# Iterate the array of rules one by one
	echo "$conf" | jq -r -c ".[]" | while read -r sconf; do
		conf_id="$(echo "$sconf" | jq -r .id )"
		i="$(_find_rule_index "$uci_path_array" "$conf_id")"

		if [ "$i" -eq "-1" ]; then
			logger "Rule does not exist, creating"

			# Intentional word splitting
			uci add $uci_cmd > /dev/null
		fi

		# Map key to value
		echo "$sconf" | jq -r --arg index "$i" --arg ucipath "$uci_path_array"  'to_entries | .[] | @text "set \($ucipath)[\($index)].\(.key)=\"\(.value)\""' | uci -q batch
	done

	# Delete undefined rules
	i=0
	while true; do
		# We finished iterating over all rules
		uci show "$uci_path_array[$i]" > /dev/null 2>&1 || break

		# If no id is defined, it's should not be there (system rule)
		id=$(uci get "$uci_path_array[$i].id" 2> /dev/null)
		if [ -z "$id" ]; then
			uci delete "$uci_path_array[$i]"
			continue
		fi

		# Check if id is still present in remote config
		if ! echo "$ret" | jq -e -r --arg id "$id" '[.[].id] | index("\($id)")' > /dev/null; then
			uci delete "$uci_path_array[$i]"
			continue
		fi

		i=$((i+1))
	done

	if [ -n "$(uci changes)" ]; then
		eval "$reload_command"
	fi
}

_set_conf_firewall_rules() {
	local conf="$1"
	local call_path="$2"

	# TODO: Add automatic target
	sconf="$(echo "$conf" | jq -r '[ .[] | {
		"name":      "\(.name)",
		"target":    "\(.target)",
		"src":       "\(.srcZone)",
		"dest":      "\(.destZone)",
		"dest_ip":   "\(.destIP)",
		"dest_port": "\(.destPort)",
		"family":    "\(.family)",
		"proto":     "\(.proto)",
		"src_ip":    "\(.srcIP)",
		"id":        "\(.id)"
	}] | del(.[][] | select(. == "null"))')"

	_set_conf_array "$sconf" "firewall.@rule" "$call_path"

	if [ -n "$(uci changes)" ]; then
		/etc/init.d/firewall reload
	fi
}

_set_conf_network_routes4(){
	local conf="$1"
	local call_path="$2"
	local reload_command="$3"

	local new_confs='[]'
	local confs=

	confs="$(echo "$conf" | jq -r -c ".[]")"
	if [ -n "$confs" ]; then
		while read -r sconf; do

			# Check if the interface is defined, otherwise get the inferface
			interface="$(echo $sconf | jq -r ".interface")"
			if [ "$interface" = "null" ]; then
				target="$(echo $sconf | jq -r ".gateway")"
				interface="$(_get_interface_ip "$target")"
			fi

			sconf="$(echo "$sconf" | jq -r --arg interface "$interface" '{
				"interface": $interface,
				"name":      "\(.name)",
				"target":    "\(.target)",
				"netmask":   "\(.netmask)",
				"gateway":   "\(.gateway)",
				"metric":    "\(.metric)",
				"mtu":       "\(.mtu)",
				"table":     "\(.table)",
				"type":      "\(.type)",
			}')"

			# Append to the new confs array
			new_confs="$(echo "$new_confs" "$sconf"  | jq '. |= .+ [input] ')"
		done <<-EOT
			${confs}
		EOT
	fi

	_set_conf_static "network" "route" "$new_confs" \
	"$reload_command" "name" '{
		"interface": "\(.interface)",
		"name":      "\(.name)",
		"target":    "\(.target)",
		"netmask":   "\(.netmask)",
		"gateway":   "\(.gateway)",
		"metric":    "\(.metric)",
		"mtu":       "\(.mtu)",
		"table":     "\(.table)",
		"type":      "\(.type)",
	}' "$call_path"
}

_restart_dnsmasq() {
	pid="$(pgrep dnsmasq)"

	/etc/init.d/dnsmasq restart

	i=0
	while [ "$i" -lt "10" ]; do
		npid="$(pgrep dnsmasq)"
		if [ -n "$npid" ] && [ "$pid" != "$npid" ]; then
			break
		fi
		sleep 1
	done

	echo "0"
}

_apply_remote_conf() {
	version="$1"
	url="$2"

	logger "Checking $url"

	# If the configuration is in cache, do not fetch it
	touch "$ACS_CACHE_PATH"
	if grep "$url" "$ACS_CACHE_PATH"; then
		logger "$url is in cache"
		return
	fi

	# Get conf JSON
	ret="$(_pull_config "$url" "$version")" || {
		logger "cannot reach $url"
		return 1
	}

	if [ "$url" = "/dhcp/config" ]; then
		reload_command="_restart_dnsmasq"
		_set_conf_static "dhcp" "dhcp" "$ret" \
			"$reload_command" "interface" '{
				"start":     "\(.offset)",
				"limit":     "\(.poolSize)",
				"leasetime": "\(.leaseDuration)",
				"interface": "\(.interface)"
			}' '/dhcp/config'

	elif [ "$url" = "/dhcp/staticLease" ]; then
		reload_command="_restart_dnsmasq"
		_set_conf_array "$ret" "dhcp.@host" '{
			"name":     "\(.hostname)",
			"mac":      "\(.mac)",
			"ip":       "\(.ip)",
			"id":       "\(.id)"
		}' "$reload_command"  "/dhcp/staticLease"

	elif [ "$url" = "/dns/localDomain" ]; then
		reload_command="_restart_dnsmasq"
		_set_conf_array "$ret" 'dhcp.@domain' '{
			"name": "\(.hostname)",
			"ip":   "\(.ip)",
			"id":   "\(.id)"
		}' "$reload_command"  '/dns/localDomain'

	elif [ "$url" = "/dns/nameserver" ]; then
		reload_command="_restart_dnsmasq"
		_set_conf_list "$ret" "server" "dhcp.@dnsmasq[0].server" \
			"$reload_command"  '/dns/nameserver'

	elif [ "$url" = "/firewall/redirect" ]; then
		reload_command="/etc/init.d/firewall reload"
		_set_conf_array "$ret" "firewall.@redirect" '{
			"name":      "\(.name)",

			"src":       "\(.srcZone)",
			"src_ip":    "\(.srcIP)",
			"src_dip":   "\(.srcDIP)",
			"src_port":  "\(.srcPort)",
			"src_dport": "\(.srcDPort)",

			"dest":      "\(.destZone)",
			"dest_ip":   "\(.destIP)",
			"dest_port": "\(.destPort)",

			"enabled":   1,
			"id":        "\(.id)",
			"proto":     "\(.proto)",
			"target":    "\(.target)",
		}' "$reload_command" "/firewall/redirect"

	# Special function used to find the network automaticaly
	elif [ "$url" = "/firewall/rule" ]; then
		reload_command="/etc/init.d/firewall reload"
		_set_conf_array "$ret" "firewall.@rule" '{
			"name":      "\(.name)",
			"target":    "\(.target)",
			"src":       "\(.srcZone)",
			"dest":      "\(.destZone)",
			"dest_ip":   "\(.destIP)",
			"dest_port": "\(.destPort)",
			"family":    "\(.family)",
			"proto":     "\(.proto)",
			"src_ip":    "\(.srcIP)",
			"id":        "\(.id)"
		}' "$reload_command" "/firewall/rule"

	elif [ "$url" = "/network/interface" ]; then
		reload_command="/etc/init.d/network reload"
		_set_conf_static 'network' 'interface' "$ret" \
		"$reload_command" "interfaceName"  '{
				"gateway":   "\(.gateway)",
				"ifname":    "\(.ifname)",
				"ip4table":  "\(.ip4table)",
				"ip6table":  "\(.ip6table)",
				"ipaddr":    "\(.ipAddr)",
				"ipv6":      "\(.ipv6)",
				"mtu":       "\(.mtu)",
				"multipath": "\(.multipath)",
				"netmask":   "\(.netmask)",
				"proto":     "\(.proto)",
				"source":    "\(.source)",
				"type":      "\(.type)"
		}' '/network/interface'

	# Special function used to find the network automaticaly
	elif [ "$url" = '/network/route4' ]; then
		reload_command="/etc/init.d/network reload"
		_set_conf_network_routes4 "$ret" '/network/route4' "$reload_command"

	elif [ "$url" = '/network/route6' ]; then
		reload_command="/etc/init.d/network reload"
		_set_conf_static \
			'network' 'routes6' \
			"$ret" "$reload_command" \
			'name' '{
				"interface": "\(.interface)",
				"target":    "\(.target)",
				"gateway":   "\(.gateway)",
				"metric":    "\(.metric)",
				"mtu":       "\(.mtu)",
				"table":     "\(.table)",
				"type":      "\(.type)",
			}' '/network/route6'

	else
		echo "Missing conf type"
	fi

	if ! _check_connect_acs "$reload_command"; then
		logger "New conf is breaking network, reversing"

		uci changes | grep -o  '[a-zA-Z]*\.' \
		| sed 's/\.$//' | sort | uniq \
		| xargs -n 1 uci revert

		eval "$reload_command"

		_update_conf_status "$url" "problem"
		return
	fi

	_update_conf_status "$url" "ok"

	uci commit
}

_run() {
	otb_reload

	if [ -z "$OTB_DEVICE_ID" ]; then
		return
	fi

	_apply_remote_conf "1" "/dhcp/config"
	_apply_remote_conf "1" "/dhcp/staticLease"
	_apply_remote_conf "1" "/dns/nameserver"
	_apply_remote_conf "1" "/firewall/redirect"
	_apply_remote_conf "1" "/firewall/rule"
	_apply_remote_conf "1" "/network/interface"
	_apply_remote_conf "1" "/network/route4"
	_apply_remote_conf "1" "/network/route6"
}

_run
